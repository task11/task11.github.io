"use strict";(self.webpackChunktask11_github_io=self.webpackChunktask11_github_io||[]).push([[623],{4765:function(e,n,t){t.d(n,{F:function(){return u},Z:function(){return E}});var l=t(7294),a=t(8733),r=t(795),o=t(6920),c=t(6799),m=t(8871);var s=e=>{let{post:n}=e;return null};const p=["16px","8px","4px"].map((e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px"));var i=e=>{let{data:{post:n},children:t}=e;return(0,a.tZ)(o.Z,null,(0,a.tZ)(r.X6,{as:"h1",variant:"styles.h1"},n.title),(0,a.tZ)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.tZ)("time",null,n.date),n.tags&&(0,a.tZ)(l.Fragment,null," — ",(0,a.tZ)(c.Z,{tags:n.tags})),n.timeToRead&&" — ",n.timeToRead&&(0,a.tZ)("span",null,n.timeToRead," min read")),(0,a.tZ)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:p.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},t),(0,a.tZ)(s,{post:n}))};const u=e=>{var n,t,l;let{data:{post:r}}=e;return(0,a.tZ)(m.Z,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(n=r.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(l=t.resize)||void 0===l?void 0:l.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function E(e){let{...n}=e;return l.createElement(i,n)}},6799:function(e,n,t){var l=t(8733),a=t(7294),r=t(1883),o=t(3494),c=t(9706);n.Z=e=>{let{tags:n}=e;const{tagsPath:t,basePath:m}=(0,o.Z)();return(0,l.tZ)(a.Fragment,null,n.map(((e,n)=>(0,l.tZ)(a.Fragment,{key:e.slug},!!n&&", ",(0,l.tZ)(r.Link,{sx:e=>{var n;return{...null===(n=e.styles)||void 0===n?void 0:n.a}},to:(0,c.Z)("/"+m+"/"+t+"/"+e.slug)},e.name)))))}},8871:function(e,n,t){var l=t(7294),a=t(1883),r=t(4232);n.Z=e=>{let{title:n="",description:t="",pathname:o="",image:c="",children:m=null,canonicalUrl:s=""}=e;const p=(0,r.Z)(),{siteTitle:i,siteTitleAlt:u,siteUrl:E,siteDescription:g,siteImage:b,author:y,siteLanguage:d}=p,h={title:n?n+" | "+i:u,description:t||g,url:""+E+(o||""),image:""+E+(c||b)};return l.createElement(l.Fragment,null,l.createElement("html",{lang:d}),l.createElement("title",null,h.title),l.createElement("meta",{name:"description",content:h.description}),l.createElement("meta",{name:"image",content:h.image}),l.createElement("meta",{property:"og:title",content:h.title}),l.createElement("meta",{property:"og:url",content:h.url}),l.createElement("meta",{property:"og:description",content:h.description}),l.createElement("meta",{property:"og:image",content:h.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:h.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:h.title}),l.createElement("meta",{name:"twitter:url",content:h.url}),l.createElement("meta",{name:"twitter:description",content:h.description}),l.createElement("meta",{name:"twitter:image",content:h.image}),l.createElement("meta",{name:"twitter:image:alt",content:h.description}),l.createElement("meta",{name:"twitter:creator",content:y}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),s?l.createElement("link",{rel:"canonical",href:s}):null,m)}},1846:function(e,n,t){t.r(n),t.d(n,{Head:function(){return c.F},default:function(){return m}});var l=t(7294),a=t(1151);function r(e){const n=Object.assign({blockquote:"blockquote",p:"p",h1:"h1",hr:"hr",h2:"h2",ul:"ul",li:"li",strong:"strong",em:"em",pre:"pre",code:"code",span:"span",h3:"h3",img:"img",ol:"ol"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"💡 자바스크립트 프로토타입 개념 이해하기"),"\n"),"\n",l.createElement(n.h1,null,"개요 🛫"),"\n",l.createElement(n.hr),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"이번 포스트에서는 자바스크립트 프로토타입을 이해할 수 있는 간단한 기저개념들과 프로토타입의 원리에 대해 공부한 점을 정리해보았다."),"\n"),"\n",l.createElement(n.p,null,"Modern Javascript Deep Dive라는 책을 구매하여 자바스크립트에대해 이해하는 시간을 가지고있다(이미지를 참조했다). Prototype이라는 개념을 이해하고 코드를 구성한다면 불필요한 중복이 제거된 활용성 있는 코드가 짜여질 것이다."),"\n",l.createElement(n.h1,null,"학습 내용 📖"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로토타입(Prototype)"),"\n",l.createElement(n.p,null,"자바스크립트는 멀티 패러다임 프로그래밍 언어이다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"imperative : 명령형"),"\n",l.createElement(n.li,null,"functional : 함수형"),"\n",l.createElement(n.li,null,"prototype-based : 프로토타입 기반"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"OOP(Object Oriented Programming) : 객체지향 프로그래밍")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"자바스크립트를 이루고 있는 거의 모든 것이 객체다.(원시 값 제외)"))),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"OOP(객체 지향 프로그래밍)"),"\n",l.createElement(n.p,null,"여러 개의 독립적인 단위, 객체의 집합으로 프로그램을 표현하는 프로그래밍 패러다임."),"\n",l.createElement(n.p,null,"사람은 이름, 나이, 성별, 주소 등 다양한 속성을 갖는다."),"\n",l.createElement(n.p,null,'구현하려는 프로그램에 사람의 "이름"과 "나이" 속성이 필요하다고하면, 이것들만 추려서 표현하는 것을 ',l.createElement(n.strong,null,"추상화(abstraction)")," 라고한다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"객체의 정의 : ",l.createElement(n.strong,null,"상태(state) -> 프로퍼티")," 와 ",l.createElement(n.strong,null,"동작(behavior) -> 메서드")," 로 이루어져 있다."),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조"),"\n",l.createElement(n.li,null,"상태 데이터와 동작을 하나의 논리적 단위로 묶은 복합적인 자료구조"),"\n"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"상속과 프로토타입"),"\n",l.createElement(n.p,null,"상속(inheritance) : 어떤 객체의 프로퍼티 or 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것."),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"자바스크립트는 프로토타입으로 상속을 구현하여 불필요한 중복을 제거한다."))),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (중복된 메서드) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 생성자 함수\nfunction Circle(radius) {\n  this.radius = radius;\n  this.getArea = function () {\n    return Math.PI * this.radius ** 2;\n  };\n}\n\n// 반지름이 1인 인스턴스 생성\nconst circle1 = new Circle(1);\n// 반지름이 2인 인스턴스 생성\nconst circle2 = new Circle(2);\n\n// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.\n// getAread 메서드는 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.(중복 코드)\nconsole.log(circle.getArea === circle2.getArea); // flase\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"메서드 중복")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 710px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 44.583333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB1klEQVR42nWS3WpTQRSF80yCQkGwJvoUXvVxSmzRWPFeeqU3raCghNDaFmulRWtqmtakmpAccyaZ5Pz/zJz5JOeUXEhdsGcuZq21Z8+aEtcwxuQFBp2B193Eaa0hvtcYN2uMTp8ims/wWlWCYYOcabL5cq0rUMqNMo3JVF4YjdKGyeEK1vsl2tsVTl/f49urMu3tB4zrt5merReXyNKFzhidG5e4AbGCSEOUgQakdPC8AGUg1MVZorkRJa0SnJ8v8c6f4Laf8+voMb0vVbyLDabNVXxrnyjWBGGKb+0yO1vFbW8wOFnj6rCaa9zWOm5nE601pTT2Ge09QtSXEI0y51vLXL0rM/34EFG/w6T1YtFd/qghPtxivFOh+3aZ9pv72I0Kcucu408rJElCSSmFFyjsiY8fGeJIkc3HigxJDL4X5mZaKcJIIZ0YOYsI/IT5k0dhhkohDFVhmGqNtIbMvh7jDPqITgd5sI/cbSCPPuMIuwgAcH0P57KN2+0gLIvJyTGTOe9gD3l5QZqmRcpz5ySOiz0MSH2fxHWJhCDs90htm3T0h3gsCIYDgt5vgn6PeCqJHYdkzg/D/6e8+JtJjBoLUiFQwiZzHPR0irZtMjkhn/WflP8CjUKX978Ila8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="prototype_1"\n        title=""\n        src="/static/ce7e297ce66946727f3210fa9cd5ea2e/6f406/prototype_1.png"\n        srcset="/static/ce7e297ce66946727f3210fa9cd5ea2e/5243c/prototype_1.png 240w,\n/static/ce7e297ce66946727f3210fa9cd5ea2e/ab158/prototype_1.png 480w,\n/static/ce7e297ce66946727f3210fa9cd5ea2e/6f406/prototype_1.png 710w"\n        sizes="(max-width: 710px) 100vw, 710px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.p,null,"모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 낭비하는 요소이다.\n",l.createElement(n.em,null,l.createElement(n.strong,null,"자바스크립트는 프로토타입으로 상속을 구현하여 불필요한 중복을 제거한다."))),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (중복된 메서드) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 생성자 함수\nfunction Circle(radius) {\n  this.radius = radius;\n}\n\n// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가한다.\n// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.\nCircle.prototype.getArea = function () {\n  return Math.PI * this.radius ** 2;\n};\n\n// 인스턴스 생성\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);\n\n// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체 역할을 하는 프로토타입(Circle.prototype)으로부터 getArea 메서드를 상속받는다.\n// getAread 메서드는 하나만 생성되어 모든 인스턴스가 공유한다(중복 코드)\nconsole.log(circle1.getArea === circle2.getArea); // true\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"프로토타입 기반의 상속을 통한 메서드 공유")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 42.083333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqklEQVR42m2QzW7TQBSF80aoKxA8A1LZIlA3LFjyDCAQQqrgHcqGbqmUKgQqJBZIESQtLKDBSSElThz/xJ6xxx7PzIfiBPF7Vvce3XvuObelgjfEJ/cJTp4wH+ziDx43fRn1WcFqjRw+JTx+gP/uEX7vIf77XZLBXdT8mL/RSkf7jA+v8ql9A6+7g/fyFpPuNdJv7WZACUnUv8e0vY13eJNhZwfv4Dqz7jbZqIuezCjPPKqvZ1gpaOWFZh5KgjBjmZXUFpJMI2SJMTVKCLIoo5zMyMO0qfU0QHwPKVIBtW5SuLrGWUvLObuOZg25lA3pnPmVwdGIqqJAZBnxeEQRhhRFQa3Uv5Gdc01hjEFtBtzmgDEVtS4oS4E1FcboxrXRiqrK0VWOsxpr9HrPuf8Ibtwtv+wRd7cYP7/Ch2cXiToXCHt3SIZ7JA1/mY/7lwhfbLF4e3sjaP8UXMX4CZmM8T8fMD3tEIxfk50fsfT7pKHH7HTNz7wjlpNXxOe9zXt+c7hCHMckSYKuKoQsCCLJIhJESU4qazJRIqQiTAoWkSSTGqVBVa551ErqB18WTs6T9lHHAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="prototype_2"\n        title=""\n        src="/static/cdcc17d139a1df46c959fa64f3ba16f2/2d1ba/prototype_2.png"\n        srcset="/static/cdcc17d139a1df46c959fa64f3ba16f2/5243c/prototype_2.png 240w,\n/static/cdcc17d139a1df46c959fa64f3ba16f2/ab158/prototype_2.png 480w,\n/static/cdcc17d139a1df46c959fa64f3ba16f2/2d1ba/prototype_2.png 768w"\n        sizes="(max-width: 768px) 100vw, 768px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"상속은 코드의 재사용이라는 관점에서 유용하다."))),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로토타입 객체"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"모든 객체는 하나의 프로토타입을 갖는다."),"\n",l.createElement(n.li,null,"모든 프로토타입은 생성자 함수와 연결되어 있다."),"\n",l.createElement(n.li,null,"객체와 프로토타입 생성자 함수는 아래 그림처럼 연결되어 있다."),"\n"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 872px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 44.583333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVR42o2RS0tVURTHzydqUiGlRg4aNei7NOpLFA0aJEQDJSODbiGIWaAUUVFplHq7hhp60XPP45573nuf/fjFvg8a2h/+/Bfrtfday7PWYoxFa8sQosYIgapHdPaEuh4RKbBDSmhcTKLKCttIvPR4jd6bq/Tf36D98jpbC1fYb80Sb8zRez1FdvJ2+I6xEH+7Q3d1iq9P5/j5/Bo7yzNsLc1ytDJNtHkLMYjwsqhD9v0B+cd7JNsP8fcWSA+WKNqPyduPyE53QFm0kCT7K6Sf7xJ+uE+0PU/QWaTfecLgxzzp3iLVIMaTylIXUPclsoRKgTQgGhDOlhqswRpDXYPIoSksooKqHE5Mo0a5Wmk8l2ysxjBSaxRGN5ixwni3uAJB05Q0qkLJgsY/pvzzG5lGKFWBtXjuKEM4tf+KJ7Bjv4uEX24Trl0g2ZjmoHWZ3aWLDN7NEK1fIty8iayzUcPz6H7pjpKdfSI9ekH/sEV+skp8+Irer2eEnWXy7jpCVHicg8kExhjyShMNFH5YUjUQxBVdP+U0KEhyhZTy/xs6LcucOAoIAp+iyAjDHj3/jDDwSZIYrTV/AZSznSrAA2rGAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="prototype_3"\n        title=""\n        src="/static/8c826fe1cd0e7766818046204fcab693/31595/prototype_3.png"\n        srcset="/static/8c826fe1cd0e7766818046204fcab693/5243c/prototype_3.png 240w,\n/static/8c826fe1cd0e7766818046204fcab693/ab158/prototype_3.png 480w,\n/static/8c826fe1cd0e7766818046204fcab693/31595/prototype_3.png 872w"\n        sizes="(max-width: 872px) 100vw, 872px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.h3,null,l.createElement(n.strong,null,"proto")," 접근자 프로퍼티"),"\n",l.createElement(n.p,null,"모든 객체는 ",l.createElement(n.strong,null,"proto")," 접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]] 내부 슬롯에 간접 접근이 가능하다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (",l.createElement(n.strong,null,"proto"),"접근자 프로퍼티) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"const obj = {};\nconst parent = { x: 1 };\n\n// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 가져옴\nobj.__proto__;\n\n// setter 함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체\nobj.__proto__ = parent;\n\nconsole.log(obj.x); // 1\n")),"\n",l.createElement(n.p,null,l.createElement(n.em,null,"*",l.createElement(n.strong,null,"*proto")," 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.",l.createElement(n.strong,null,"proto")," 접근자 프로퍼티 사용이 가능하다.**")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"프로토타입에 접근하기위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서 이다."),"\n"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 430px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 69.16666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACWUlEQVR42n2S22oTQRyHA7VNbfERpND6AArRR1AQL5QWvBBvalPvfQhBRHyE3olgPdSkJq1pTbNWKnhpQaGmtU2a7CZtDnvMZmY+yW5iD8YOfMww881/fjNMRIo2rqnjWTpuH3xHp+0aAb4dzvV3K0gpiFgHP8nPj6EvTlBKnKScmGDr1Tg/XobkX49TTo6f8i6hJ8fYfn8Nu2kQsaubGG+GcJdGsFMncdKjrDyLkn4ySPb5EJtzw7QyF7A/HPdG8VKDGMkx7EaZiNMokl99wL4Wp5CboajFKebiFNZnKSfuoafuU9p4SHk9TunzDHvJuxR7XsAs+9o0O9ojXLtOhDOa8kCaIhx3EUbzrC1ElFIoJZCNGt4XDVfL4mYzCKOENOtIsxGU6jhK+IEHEiXbXUS4FqDCgp0mbQtRqSCbDWS9jrRMpBkSRlQoKZH12r83CUKp4wkVqk986TjBAaq3SQhELSyoWi2k2US6zt/nCBIevY48BeA5YPXeTEHnWmYDVdHxN9ZpZVfwv31FFnZB+L2E4PngnsKT4FRMbKOB13Ha4HrgFQ9xHRWMXdH1HRXU6MSKOPXf7GZuU9Em0dcm0XNhb2hT6Es3MT7eopybYv9TOF+dv4HR8TrrgT9FRbvD3to0rnUYfuzq23P4y8O46SOcVBSxMsL3uSiZpwMsPh5g58UQ7dUR3NQwXjradc/jpweoJC+GH9s63GJ74QrG8lXK6RjldK8P2U3EyC/E+PUuRmExhn5srefr6cvspK5jm1UiUgis5gG22R/HOsC1Qxzz/55t1pBS8gc6R8v+S7C03wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="prototype_4"\n        title=""\n        src="/static/5f1bb8b1d9c3a04b1c5553ba57175ff9/4b52d/prototype_4.png"\n        srcset="/static/5f1bb8b1d9c3a04b1c5553ba57175ff9/5243c/prototype_4.png 240w,\n/static/5f1bb8b1d9c3a04b1c5553ba57175ff9/4b52d/prototype_4.png 430w"\n        sizes="(max-width: 430px) 100vw, 430px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.p,null,l.createElement(n.em,null,"프로토타입 체인에서 프로퍼티를 검색할 때 무한루프에 빠지지 않게.")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"proto")," 접근자 프로퍼티를 코드 내에서 직접 사용하는 것을 권장하지는 않는다."),"\n"),"\n",l.createElement(n.p,null,": 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성한 경우에 ",l.createElement(n.strong,null,"proto"),"를 사용할 수 없기 때문이다. (모든 객체가 ",l.createElement(n.strong,null,"proto"),"접근자 프로퍼티를 사용할 수 있는게 아니여서)"),"\n",l.createElement(n.p,null,"*",l.createElement(n.strong,null,"*proto"),"대신 사용할 메서드 :**"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Object.getPrototypeOf : 참조 취득 (ES5)"),"\n",l.createElement(n.li,null,"Object.setPrototypeOf : 프로토타입 교체 (ES6)"),"\n"),"\n",l.createElement(n.h3,null,"함수 객체의 prototype 프로퍼티"),"\n",l.createElement(n.p,null,"함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다."),"\n",l.createElement(n.p,null,"*",l.createElement(n.strong,null,"*proto"),"접근자 프로퍼티와 함수객체의 prototype 프로퍼티의 사용 주체 :**"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 22.499999999999996%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA9klEQVR42i2O25KDIBBE/f8/3H1IdoOJCIIoco3xbEHtw0xN91RfhtEetLEFpC+IZWfJV8fPNWDzhQon30Jyny1LpnPtPx+Vr9+paxo2+WIYp5n9iJQTjNuxbieUE+M2lFlxPuBTRaoFHxJm84yTRGpD095+HjyeE9q6jofXNKG1pr5Pdu9JKfXbOce2bRwhkEvFHwfn54Pbdh5CEGKk1kouhVIKKWdijAxiHPtxQRd774k5Y9e1T8MpF5RSpNR4x+1+R0rJPM8IIXpA+y/GMLTVzM7PRUwtJf03Cr1VTIlc3719a974SUqerxez0hhrUVpTau0+f9IqfggDd8eZAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="prototype_5"\n        title=""\n        src="/static/2669cbfa6c371c518cb9bd66331650da/7d769/prototype_5.png"\n        srcset="/static/2669cbfa6c371c518cb9bd66331650da/5243c/prototype_5.png 240w,\n/static/2669cbfa6c371c518cb9bd66331650da/ab158/prototype_5.png 480w,\n/static/2669cbfa6c371c518cb9bd66331650da/7d769/prototype_5.png 960w,\n/static/2669cbfa6c371c518cb9bd66331650da/f46b1/prototype_5.png 1260w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로토타입의 생성 시점"),"\n",l.createElement(n.p,null,"프로토타입은 생성자 함수가 생성되는 시점에 같이 생성된다."),"\n",l.createElement(n.h3,null,"1) 사용자 정의 생성자 함수"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입이 생성된다.\n",l.createElement(n.em,null,l.createElement(n.strong,null,"런타임 이전에 자바스크립트 엔진에서 호이스팅된 함수를 정의한다. 이때 프로토타입이 같이 생성된다."))),"\n"),"\n",l.createElement(n.h3,null,"2) 빌트인 생성자 함수"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"Object, String, Number 등의 빌트인 생성자 함수들은 전역 객체가 생성되는 시점에 모든 프로토타입이 생성된다.\n",l.createElement(n.em,null,l.createElement(n.strong,null,"런타임 이전에 자바스크립트 엔진에서 전영 객체를 생성한다. 이때 프로토타입이 같이 생성된다."))),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"클라이언트 사이드 환경(브라우저)에서의 전역 객체 : window"),"\n",l.createElement(n.li,null,"서버 사이드 환경(node)에서의 전역 객체 : global"),"\n"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"객체 생성 방식과 프로토타입의 결정"),"\n",l.createElement(n.p,null,"객체의 생성 방법 :"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"객체 리터럴 : OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다."),"\n",l.createElement(n.li,null,"Object 생성자 함수 : OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다."),"\n",l.createElement(n.li,null,"생성자 함수 : OrdinaryObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다."),"\n",l.createElement(n.li,null,"Object.create 메서드"),"\n",l.createElement(n.li,null,"클래스(ES6)"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다."))),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로토타입 체인 (prototype chain)"),"\n",l.createElement(n.p,null,"스코프 체인(scope chain)과 유사하게 상속받은 최상위 프로토타입을 종점으로 하여 부모 프로토타입의 프로퍼티를 찾아 가는 것을 프로토타입 체인이라고 한다."),"\n",l.createElement(n.img,{src:"prototype_6.png",alt:"prototype_6"}),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"프로토타입 체인의 종점 (End of Prototype Chain) : Object.prototype"))),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"오버라이딩과 프로퍼티 섀도잉"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Overriding & Property Shadowing) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"const Person = (function () {\n  // 생성자 함수\n  function Person(name) {\n    this.name = name;\n  }\n\n  // 프로토타입 메서드\n  Person.prototype.sayHello = function () {\n    console.log(`Hi~ My name is ${this.name}`);\n  };\n\n  // 생성자 함수 반환\n  return Person;\n})();\n\nconst me = new Person(\"Kim\");\n\n// 인스턴스 메서드\nme.sayHello = function () {\n  console.log(`Hello World i'm ${this.name}`);\n};\n\n// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.\nme.sayHello(); // Hello World i'm Kim\n")),"\n",l.createElement(n.p,null,"위 예제 코드에서"),"\n",l.createElement(n.p,null,"인스턴스 메서드 sayHello는 프로토타입 메서드 sayHello를 오버라이딩했고 프로토타입 메서드 sayHello는 가려진다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"상속 관계에 의해 부모 프로퍼티 메서드가 가려지는 것을 프로퍼티 섀도잉(Property Shadowing)이라고 한다."),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Overriding & Property Shadowing) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 인스턴스 메서드를 삭제한다.\ndelete me.sayHello;\n\n// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.\nme.sayHello(); // Hi ~ My name is Kim\n\n// 이번에는 프로토타입 메서드를 삭제한다.\ndelete me.sayHello; // 하위 객체를 통한 상위 프로퍼티의 set 액세스는 혀용 불가하다.\n\n// 삭제 되지 않았다.\nme.sayHello(); // Hi ~ My name is Kim\n")),"\n",l.createElement(n.p,null,"위 예제 코드처럼 하위 객체를 통한(프로토타입 체인을 통한) 상위 프로퍼티의 set 액세스는 불가능하다.\n상위 프로퍼티의 set 액세스를 위해서는 프로토타입에 직접 접근해야한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (프로토타입 직접 접근) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 프로토타입 메서드 변경\nPerson.prototype.sayHello = function () {\n  console.log(`Hello World i'm ${this.name}`);\n};\n\nme.sayHello(); // Hello World i'm Kim\n\n// 프로토타입 메서드 삭제\ndelete Person.prototype.sayHello;\nme.sayHello(); // TypeError: me.sayHello is not a function\n")),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로토타입 교체"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"생성자 함수를 이용한 교체"),"\n",l.createElement(n.li,null,"인스턴스에 의한 교체"),"\n"),"\n",l.createElement(n.h3,null,"생성자 함수에 의한 프로토타입 교체"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (생성자 함수 프로토타입 교체) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'const Person = (function () {\n  function Person(name) {\n    this.name = name;\n  }\n\n  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체\n  Person.prototype = {\n    sayHello() {\n      console.log(`Hi~ My name is ${this.name}`);\n    },\n  };\n\n  return Person;\n})();\n\nconst me = new Person("kim");\n')),"\n",l.createElement(n.p,null,"Person.prototype에 객체 리터럴을 할당한 것은 Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것."),"\n",l.createElement(n.p,null,"교체한 객체 리터럴에는 constructor 프로퍼티가 없다. ",l.createElement(n.strong,null,"me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다.")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (constructor 프로퍼티 부재) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 프로퍼티를 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.\nconsole.log(me.constructor === Person); // false;\n\n// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼탁 검색된다. ( 상위 부모 : Object.prototype)\nconsole.log(me.constructor === Object); // true;\n")),"\n",l.createElement(n.p,null,"위와 같은 문제를 해결하기 위해서는 객체 리터럴에 constructor 프로퍼티를 추가하고, prototype 프로퍼티를 재설정 해야한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (constructor 프로퍼티 추가) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'function Person(name) {\n  this.name = name;\n}\n\nconst me = new Person("Kim");\n\n// 교체할 객체 리터럴\nconst parent = {\n  constructor: Person, // 추가\n  sayHello() {\n    console.log(`Hi~ My name is ${this.name}`);\n  },\n};\n\n// 프로토타입 연결\nPerson.prototype = parent;\n\n// me의 객체 프로토타입을 parent로 교체한다.\nObject.setPrototypeOf(me, parent);\n')),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"프로토타입은 직접 교체하지 않는게 좋다. 직접 상속을 이용하거나 ES6의 클래스를 사용하여 구현하도록 하자."))),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"instanceof 연산자"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"객체 instanceof 생성자 함수"),"\n"),"\n",l.createElement(n.p,null,"우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 상에 존재하면 true 로 평가, 반대의 경우에는 TypeError 발생."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (instanceof) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'function Person(name) {\n  this.name = name;\n}\n\nconst me = new Person("kim");\n\nconst parent = {};\n\nObject.setPrototypeOf(me, parent);\n\nconsole.log(Person.prototype === parent); // false\nconsole.log(parent.constructor); // Object\n\nconsole.log(me instanceof Person); // false\n\nconsole.log(me instanceof Object); // true\n\nconsole.log(parent instanceof Person); // false\n\nPerson.prototype = parent; // parent 객체를 Person 생성자 함수의 prototype 프로퍼티에 바인딩한다.\n\nconsole.log(me instanceof Person); // true\nconsole.log(Person.prototype === parent); // true\n')),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"바인딩을 필수적으로 해줘야한다."))),"\n",l.createElement(n.h3,null,"istanceof 연산자 구현"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (instanceof) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"function Person(name) {\n  this.name = name;\n}\n\nconst me = new Person();\n\nfunction isInstanceof(instance, constructor) {\n  // 프로토타입 획득\n  const prototype = Object.getPrototypeOf(instance);\n\n  // 재귀 탈출 조건\n  // prototype이 null -> 프로토타입 체인의 종점\n  if (prototype === null) return false;\n\n  // 프로토타입이 생성자 함수의 prototype 프로퍼티에 바인딩된 객체라면 true를 반환.\n  // 그렇지 않으면 재귀 호출로 프로토타입 체인상 상위 프로토타입으로 이동하여 확인.\n  return (\n    prototype === constructor.prototype || isInstanceof(prototype, constructor)\n  );\n  // 단축 평가\n}\n\nconsole.log(isInstanceof(me, Person)); // true\nconsole.log(isInstanceof(me, Object)); // true\n")),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"직접 상속"),"\n",l.createElement(n.h3,null,"Object.create 직접 상속"),"\n",l.createElement(n.p,null,"Object.create 메서드의 첫 번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두 번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체를 전달한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Object.create) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// Object.create(prototype[, propertiesObject]);\n\n// Object.create 직접 상속\n// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.\n// obj -> null\nlet obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj) === null); // true\n// Object.prototype을 상속받지 못한다.\n//console.log(obj.toString()); // TypeError: obj.toString is not a function\n\n// obj -> Object.prototype -> null\n// obj = {}; 와 동일하다.\nobj = Object.create(Object.prototype);\n// Objet.prototype를 상속받는다.\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true\n\n// obj -> Object.prototype -> null\n// obj = {x: 1}; 와 동일하다.\nobj = Object.create(Object.prototype, {\n  x: { value: 1, writable: true, enumerable: true, configurable: true },\n});\n// 위 코드는 아래와 동일\n// obj = Object.create(Object.prototype);\n// obj.x = 1;\nconsole.log(obj.x);\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true\n\nconst myProto = { x: 10 };\n// obj -> myProto -> Object.prototype -> null\nobj = Object.create(myProto);\nconsole.log(obj.x);\nconsole.log(Object.getPrototypeOf(obj) === myProto); // true\n\n// 생성자 함수\nfunction Person(name) {\n  this.name = name;\n}\n\n// obj -> Person.prototype -> Object.prototype -> null\n// obj = new Person('Kim')과 동일\nobj = Object.create(Person.prototype);\nobj.name = \"Kim\";\nconsole.log(obj.name); // Kim\nconsole.log(Object.getPrototypeOf(obj) === Person.prototype); // true\n")),"\n",l.createElement(n.p,null,"Object.create 장점 :"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"new 연산자 없이 객체 생성 가능"),"\n",l.createElement(n.li,null,"프로토타입을 지정하며 객체 생성 가능"),"\n",l.createElement(n.li,null,"객체 리터럴로 생성된 객체도 상속 가능"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"프로토타입 체인의 종점에 위치하는 객체는 Object.property의 빌트인 메서드를 사용할 수 없는데, Object.create에서 Object.prototype 메서드를 직접 호출하면 프로토타입 체인 종점에 위치하는 객체를 생성할 수 있으므로 Object.prototype 메서드의 직접적인 사용을 권장하지 않는다."))),"\n",l.createElement(n.p,null,"Object.prototype 메서드의 간접 호출 방법"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (간접 호출) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"// 프로토타입이 null 인 객체 생성\nlet obj = Object.create(null);\nobj.a = 1;\n\n// console.log(obj.hasOwnProperty('a')) // TypeError....\n\n// 메서드 간접 호출\nconsole.log(Object.prototype.hasOwnProperty.call(obj, \"a\")); // true\n")),"\n",l.createElement(n.h3,null,"객체 리터럴 내부에서 ",l.createElement(n.strong,null,"proto"),"에 의한 직접 상속"),"\n",l.createElement(n.p,null,"Object.create의 단점"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"두 번째 인자로 프로퍼티를 정의하는 것이 번거로움"),"\n"),"\n",l.createElement(n.p,null,"ES6에서는 객체 리터럴 내부에서 ",l.createElement(n.strong,null,"proto"),"접근자 프로퍼티를 사용해 직접 상속 구현이 가능하다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (",l.createElement(n.strong,null,"proto"),") :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"const myProto = { x: 10 };\n\n// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받기\nconst obj = {\n  y: 20,\n  // 객체 직접 상속\n  // obj -> myProto -> Object.prototype -> null\n  __proto__: myProto,\n};\n\n/* 위 코드는 아래오 ㅏ동일\nconst obj = Object.create(myProtom {\n  y: {value: 20, ......}\n})\n*/\n\nconsole.log(obj.x, obj.y); // 10, 20\nconsole.log(Object.getPrototypeOf(obj) === myProto); // true\n")),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"정적 프로퍼티/메서드"),"\n",l.createElement(n.p,null,"정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드이다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Static Property & Method) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'// 생성자 함수\nfunction Person(name) {\n  this.name = name;\n}\n\n// 프로토타입 메서드\nPerson.prototype.sayHello = function () {\n  console.log(`Hi My name is ${this.name}`);\n};\n\n// 정적 프로퍼티\nPerson.staticProp = "static prop";\n\n// 정적 메서드\nPerson.staticMethod = function () {\n  console.log("static method");\n};\n\nconst me = new Person("Kim");\n\nPerson.staticMethod();\n\nlet a = Person.staticProp;\n\nconsole.log(a);\n\n// 정적 메서드, 프로퍼티는 생성자 함수가 생성한 인스턴스로 호출이 불가하다.\n// me.staticMethod(); // TypeError: me.staticMethod is not a function\n')),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"정적 프로퍼티/메서드는 Person 생성자 함수가 소유한다. 생성자 함수가 생성한 인스턴스(me)로는 참조하거나 호출할 수 없다."))),"\n",l.createElement(n.p,null,"인스턴스/ 프로토타입 메서드에서 this로 바인딩 되는 프로퍼티가 없다면 그 메서드는 정적 메서드로 변경이 가능하다."),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로퍼티 존재 확인"),"\n",l.createElement(n.h3,null,"in 연산자"),"\n",l.createElement(n.p,null,"in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (in 연산자 사용법) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"/*\n  key: 프로퍼티 키\n  object: 객체로 평가되는 표현식\n*/\nkey in object;\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (in 연산자) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'const person = {\n  name: "Kim",\n  region: "Seoul",\n};\n\nconsole.log("name" in person); // true\n\nconsole.log("toString" in person); // true\n')),"\n",l.createElement(n.p,null,'"toString" 이라는 메서드가 객체안에 없지만 true가 나온 이유는, in 연산자가 person 객체가 속한 프로토타입 체인을 따라 검색했기 때문이다. ',l.createElement(n.strong,null,"toString은 Object.prototype의 메서드이다.")),"\n",l.createElement(n.p,null,"in 연산자 대신 ES6에서 나온 Reflect.has 메서드도 사용할 수 있다. ( in 연산자와 동작은 같음 )"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Reflect.has) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'const person = {\n  name: "Kim",\n  region: "Seoul",\n};\n\nconsole.log(Reflect.has(person, "name")); // true\n\nconsole.log(Reflect.has(person, "toString")); // true\n')),"\n",l.createElement(n.h3,null,"Object.prototype.hasOwnProperty"),"\n",l.createElement(n.p,null,"Object.prototype.hasOwnProperty 메서드 또한 객체에 특정 프로퍼티가 있는지 확인할 수 있다."),"\n",l.createElement(n.p,null,"차이점 : 고유의 프로퍼티 외에 상속받은 프로퍼티나 메서드는 false로 처리한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (Reflect.has) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'console.log(person.hasOwnProperty("name")); // true\nconsole.log(person.hasOwnProperty("toString")); // false\n')),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"프로퍼티 열거 (Property Enumeration)"),"\n",l.createElement(n.h3,null,"for... in 문"),"\n",l.createElement(n.p,null,"객체의 모든 프로퍼티를 순회하며 열거하려면 for in 문을 사용한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"for (변수선언문 in 객체) {...}\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (for in) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'const person = {\n  name: "kim",\n  region: "Seoul",\n};\n\nfor (const key in person) {\n  console.log(key + ": " + person[key]);\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.em,null,l.createElement(n.strong,null,"for in 문은 상속받은 프로토타입의 프로퍼티까지 열거하는데, Object.prototype의 프로퍼티가 열거되지 않는 이유는, 프로퍼티 속성 값에 열거할 수 없도록 정의되어 있기 때문이다.(enumable : false)"))),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"또한 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.."),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"for in 문은 열거 순서를 보장하지 않는다. (대부분 모던 브라우저들은 보장해줌)"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example Code (상속받은 프로퍼티는 제외하고 자신의 프로퍼티만 열거) :")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},'const person = {\n  name: "kim",\n  region: "Seoul",\n  __proto__: { age: 20 },\n};\n\nfor (const key in person) {\n  // 객체 자신의 프로퍼티인지 확인\n  if (!person.hasOwnProperty(key)) contiue;\n  console.log(key + ": " + person[key]);\n}\n')),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"javascript의 배열에는 for in 문보다는 일반적인 for 문이나 for of 문 또는 Array.prototype.forEach메서드를 사용하기를 권장한다. (배열도 객체이므로 상속받은 프로퍼티가 튀어나올 수 있어서)"),"\n"),"\n",l.createElement(n.h3,null,"Object.key / values / entries 메서드"),"\n",l.createElement(n.p,null,"위 예제 처럼 for in 문에 hasOwnProperty 메서드를 사용하여 자기 자신 객체인지 확인하는 방법도 있지만.\n되도록이면 Object.key / values / entries 메서드를 사용하는 것을 권장한다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Object.keys : 객체 자신이 열거 가능한 프로퍼티 ",l.createElement(n.strong,null,"키를")," 배열로 반환한다."),"\n",l.createElement(n.li,null,"Object.values : 객체 자신이 열거 가능한 프로퍼티 ",l.createElement(n.strong,null,"값을")," 배열로 반환한다."),"\n",l.createElement(n.li,null,"Object.entries : 객체 자신이 열거 가능한 프로퍼티 ",l.createElement(n.strong,null,"키와 값의 쌍을")," 배열로 반환한다. ",l.createElement(n.em,null,l.createElement(n.strong,null,"ES6.."))),"\n"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h1,null,"Review 💡"),"\n",l.createElement(n.p,null,"이번 포스트에는 자바스크립트의 프로토타입에 대한 원리를 이해하고 알아보는 시간을 가졌다. 다음 ",l.createElement(n.code,null,"알고리즘 포스트"),"에서는 다양한 자료구조들을 프로토타입 형태로 구현하여 사용해볼 것이다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.code,null,"NEXT POST")),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Linear Data Structure(선형 자료구조)"),"\n"),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"Linked List(연결리스트)"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"Doubly Linked List(이중 연결리스트)"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"Circular Linked List(원형 연결리스트)"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"Stack(스택)"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"Queue(큐)"),"\n"),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.ol,{start:"2"},"\n",l.createElement(n.li,null,"Non-Linear Data Structure(비선형 자료구조)"),"\n"),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Priority Queue(우선순위 큐)"),"\n",l.createElement(n.li,null,"Circluar Queue(원형 큐)"),"\n",l.createElement(n.li,null,"Deque(데크)"),"\n",l.createElement(n.li,null,"Dictionary(딕셔너리)"),"\n",l.createElement(n.li,null,"HashTable(해시테이블)"),"\n",l.createElement(n.li,null,"Changing HashTable(체이닝 해시테이블)"),"\n",l.createElement(n.li,null,"Tree(트리)"),"\n",l.createElement(n.li,null,"Graph(그래프)"),"\n"),"\n",l.createElement(n.h1,null,"References 🙏🏽"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Modern Javascript Deep Dive"),"\n"))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)},c=t(4765);function m(e){return l.createElement(c.Z,e,l.createElement(o,e))}c.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-prototype-index-mdx-7447b1bffd0f01d81bce.js.map